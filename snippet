{
	"contract_skeleton": {
		"scope": "solidity",
		"prefix": "contract_skeleton",
		"body": [
			"pragma solidity ^0.4.17;",
			"",
			"contract Forgetmenot {",
			"$1",
			"}"
		],
		"description": "Creates the main contract layout"
	},
	"contract_Entry": {
		"scope": "solidity",
		"prefix": "contract_Entry",
		"body": [
			"  struct Entry {",
			"    string key;",
			"    string value;",
			"    uint createdBlock;",
			"    uint linkToPreviousBlock;",
			"  }"
		],
		"description": ""
	},
	"contract_addressToEntryMapping": {
		"scope": "solidity",
		"prefix": "contract_addressToEntryMapping",
		"body": [
			"  mapping (address => Entry) private addressToEntryMapping; "
		],
		"description": ""
	},
	"contract_createEntry": {
		"scope": "solidity",
		"prefix": "contract_createEntry",
		"body": [
			"  function createEntry (string _key, string _value)",
			"  public",
			"  {",
			"    Entry storage entry = addressToEntryMapping[msg.sender];",
			"    entry.linkToPreviousBlock = entry.createdBlock;",
			"    entry.createdBlock = block.number;",
			"",
			"    entry.key = _key;",
			"    entry.value = _value;",
			"  }",
		],
		"description": " Create the function to add new entries"
	},
	"contract_fetchEntry": {
		"scope": "solidity",
		"prefix": "contract_fetchEntry",
		"body": [
			"  function fetchEntry ()",
			"  public",
			"  view",
			"  returns (string, string, uint, uint)",
			"  {",
			"    return (",
			"      addressToEntryMapping[msg.sender].key,",
			"      addressToEntryMapping[msg.sender].value,",
			"      addressToEntryMapping[msg.sender].createdBlock,",
			"      addressToEntryMapping[msg.sender].linkToPreviousBlock",
			"    );",
			"  }",
		],
		"description": "Create the function to get entries"
	},
	"test_skeleton": {
		"scope": "javascript",
		"prefix": "test_skeleton",
		"body": [
			"const $1 = artifacts.require('$1');",
			"contract('Test Name', async (accounts) => {",
		  "",
		  "  function assertEventOfType (response, eventName, index) {",
		  "    assert.equal(response.logs[index].event, eventName, eventName + ' event should fire.');",
		  "  }",
		  "",
		  "  it('should ...', async () => {",
		  "    let instance = await $1.deployed();",
		  "    await instance.$2($3, { from: accounts[0] });",
		  "  })",
		  "})",
		],
		"description": "Create the function to get entries"
	}
}